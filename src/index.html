<html>
  <head>
    <title>ColorMoves</title>
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1" />
    <link rel="stylesheet" type="text/css" href="ColorMoves.css" />
    <link
      rel="stylesheet"
      href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css"
    />
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <script type="text/javascript" src="lib/gl-matrix.min.js"></script>
    <script type="text/javascript" src="lib/webgl-utils.js"></script>
    <script
      type="text/javascript"
      src="lib/fits/fits.js"
      charset="utf-8"
    ></script>
    <script type="text/javascript" src="lib/jszip.min.js"></script>
    <script type="text/javascript" src="Utility.js"></script>
    <script type="text/javascript" src="PngChunkReader.js"></script>
    <script type="text/javascript" src="ImageReader.js"></script>
    <script type="text/javascript" src="ColormapReader.js"></script>
    <script type="text/javascript" src="Viewer.js"></script>
    <script type="text/javascript" src="ImageCanvas.js"></script>
    <script type="text/javascript" src="ColorMapCanvas.js"></script>
    <script type="text/javascript" src="ColorMapPicker.js"></script>
    <script type="text/javascript" src="ActionManager.js"></script>
    <script type="text/javascript" src="ColorMapCreator.js"></script>
    <script type="text/javascript" src="Graphics.js"></script>
    <script type="text/javascript" src="Input.js"></script>

    <!-- >>> Shaders -->

    <script id="vsSimple" type="x-shader/x-vertex">
        attribute vec3 vpos;
      attribute vec2 vtexcoord;
      uniform mat4 matWorldViewProj;
      varying vec2 uv;

      void main()
      {
      	gl_Position = matWorldViewProj * vec4(vpos, 1.0);
      	uv = vtexcoord;
      }
    </script>
    <script id="vsAlpha" type="x-shader/x-vertex">
        precision mediump float;
      precision mediump int;
      uniform float colorMapStart[15], colorMapEnd[15];
      uniform float colorMapStartValue[15], colorMapEndValue[15];
      uniform float colorMapStartAlpha[15], colorMapEndAlpha[15];
      uniform int colorMapFlipped[15];
      attribute vec3 vpos;
      uniform mat4 matWorldViewProj;
      uniform mat4 matTexCoordTransform;
      varying vec2 uv;

      void main()
      {
      	float u = ((matTexCoordTransform * vec4(2.0 * vpos.x - 1.0, 0.0, 0.0, 1.0)).x + 1.0) / 2.0;
      	uv = vec2(u, 0.5);

      	if(vpos.y != 0.0)
      	{
      		float y = 1.0;
      		for(int i = 0; i < 15; ++i)
      			if(uv.x >= colorMapStart[i] && uv.x <= colorMapEnd[i])
      			{
      				float v = (uv.x - colorMapStart[i]) / (colorMapEnd[i] - colorMapStart[i]);
      				float a = v * colorMapEndAlpha[i] + (1.0 - v) * colorMapStartAlpha[i];
      				y = 1.0 + a * 9.0;
      				break;
      			}
      		gl_Position = matWorldViewProj * vec4(vpos.x, y, vpos.z, 1.0);
      	}
      	else
      		gl_Position = matWorldViewProj * vec4(vpos, 1.0);
      }
    </script>
    <script id="fsSimple" type="x-shader/x-fragment">
        precision mediump float;
      varying vec2 uv;
      uniform sampler2D uSampler;

      void main()
      {
      	gl_FragColor = texture2D(uSampler, uv);
      }
    </script>
    <script id="fsLine" type="x-shader/x-fragment">
        precision mediump float;
      uniform vec4 color;

      void main()
      {
      	gl_FragColor = color;
      }
    </script>
    <script id="fsHighlight" type="x-shader/x-fragment">
        precision mediump float;
      varying vec2 uv;

      void main()
      {
      	gl_FragColor = vec4(1.0, 0.0, 0.0, 0.4 + 0.2 * uv.x * uv.y);
      }
    </script>
    <script id="fsColorMapping" type="x-shader/x-fragment">
        precision mediump float;
      	precision mediump int;
      	uniform float colorMapStart[15], colorMapEnd[15];
      	uniform float colorMapStartValue[15], colorMapEndValue[15];
      	uniform float colorMapStartAlpha[15], colorMapEndAlpha[15];
      	uniform int colorMapFlipped[15];
      	varying vec2 uv;
      	uniform sampler2D uSampler, colorMap[15];
      	uniform vec3 NanColor;
      	uniform vec2 InvSize;
      	uniform float highlightValue;

      	float sampleValue(in sampler2D sampler, in vec2 uv)
      	{
      		// Get float value (valueS) from RGB data
      		vec4 rgba = texture2D(sampler, uv);
      		if(rgba.a <= 1e-5)
      			return -1e20;
      		float valueI = floor(rgba.r * 255.0) * 65536.0 + floor(rgba.g * 255.0) * 256.0 + floor(rgba.b * 255.0);
      		if(valueI < 0.5)
      			return -1e20;
      		float valueS = (valueI - 1.0) / 16777214.0; // 0 is reserved as 'nothing' //float(0xfffffe)
      		valueS = clamp(valueS, 0.0, 1.0);
      		return valueS;
      	}
      	/*float sampleValue(in sampler2D sampler, in vec2 uv)
      	{
      		// Get float value from float texture data
      		return texture2D(sampler, uv).r;
      	}*/

      	void main()
      	{
      /*vec4 c = texture2D(uSampler, uv);
      gl_FragColor = vec4(c.r, 0.0, 0.0, 1.0);
      return;*/
      		float value = sampleValue(uSampler, uv);
      		if (value == -1e20)
      		{
      			gl_FragColor = vec4(NanColor, 0.0);
      			return;
      		}

      		/*float n1, n2;
      		if (highlightValue != -1e20 && (n1 = sampleValue(uSampler, uv + vec2(InvSize.x, 0.0))) != -1e20 && (n2 = sampleValue(uSampler, uv + vec2(0.0, InvSize.y))) != -1e20)
      		{
      			float diff = sign(value - highlightValue) * sign(highlightValue - n1) + sign(value - highlightValue) * sign(highlightValue - n2);
      			if (diff > 0.0)
      			{
      				gl_FragColor = vec4(0.5 * diff, 0.0, 0.0, 1.0);
      				return;
      			}
      		}*/

      		float f, n, h = 0.0;
      		if (highlightValue != -1e20 &&(n = sampleValue(uSampler, uv + vec2(-InvSize.x, 0.0))) != -1e20 &&
      			(f = (highlightValue - n) / (value - n)) > 0.0 && f <= 1.0)
      			h += f;
      		if (highlightValue != -1e20 && (n = sampleValue(uSampler, uv + vec2(InvSize.x, 0.0))) != -1e20 &&
      			(f = (highlightValue - n) / (value - n)) > 0.0 && f <= 1.0)
      			h += f;
      		if (highlightValue != -1e20 && (n = sampleValue(uSampler, uv + vec2(0.0, -InvSize.y))) != -1e20 &&
      			(f = (highlightValue - n) / (value - n)) > 0.0 && f <= 1.0)
      			h += f;
      		if (highlightValue != -1e20 && (n = sampleValue(uSampler, uv + vec2(0.0, InvSize.y))) != -1e20 &&
      			(f = (highlightValue - n) / (value - n)) > 0.0 && f <= 1.0)
      			h += f;
      		h /= 2.0;

      /*vec3 rgb = texture2D(uSampler, uv).rgb;
      float value = rgb.g;
      gl_FragColor = vec4(value, value, value, 1.0);
      return;*/

      		/*for(int i = 0; i < 15; ++i)
      			if(value >= colorMapStart[i] && value <= colorMapEnd[i])
      			{
      				float v = (value - colorMapStart[i]) / (colorMapEnd[i] - colorMapStart[i]);
      				v = (v - colorMapStartValue[i]) / (colorMapEndValue[i] - colorMapStartValue[i]);
      				float a = v * colorMapEndAlpha[i] + (1.0 - v) * colorMapStartAlpha[i];
      				if(colorMapFlipped[i] == 1) v = 1.0 - v;
      				gl_FragColor = vec4(texture2D(colorMap[i], vec2(v, 0.5)).rgb + vec3(-h, h, -h), a + h);
      				//return; // Warning: This causes artifacts on Chromium (Do not un-comment!)
      			}*/

      		if(value >= colorMapStart[0] && value <= colorMapEnd[0])
      		{
      			float v = (value - colorMapStart[0]) / (colorMapEnd[0] - colorMapStart[0]);
      			v = (v - colorMapStartValue[0]) / (colorMapEndValue[0] - colorMapStartValue[0]);
      			float a = v * colorMapEndAlpha[0] + (1.0 - v) * colorMapStartAlpha[0];
      			if(colorMapFlipped[0] == 1) v = 1.0 - v;
      			gl_FragColor = vec4(texture2D(colorMap[0], vec2(v, 0.5)).rgb + vec3(-h, h, -h), a + h);
      		}
      		else if(value >= colorMapStart[1] && value <= colorMapEnd[1])
      		{
      			float v = (value - colorMapStart[1]) / (colorMapEnd[1] - colorMapStart[1]);
      			v = (v - colorMapStartValue[1]) / (colorMapEndValue[1] - colorMapStartValue[1]);
      			float a = v * colorMapEndAlpha[1] + (1.0 - v) * colorMapStartAlpha[1];
      			if(colorMapFlipped[1] == 1) v = 1.0 - v;
      			gl_FragColor = vec4(texture2D(colorMap[1], vec2(v, 0.5)).rgb + vec3(-h, h, -h), a + h);
      		}
      		else if(value >= colorMapStart[2] && value <= colorMapEnd[2])
      		{
      			float v = (value - colorMapStart[2]) / (colorMapEnd[2] - colorMapStart[2]);
      			v = (v - colorMapStartValue[2]) / (colorMapEndValue[2] - colorMapStartValue[2]);
      			float a = v * colorMapEndAlpha[2] + (1.0 - v) * colorMapStartAlpha[2];
      			if(colorMapFlipped[2] == 1) v = 1.0 - v;
      			gl_FragColor = vec4(texture2D(colorMap[2], vec2(v, 0.5)).rgb + vec3(-h, h, -h), a + h);
      		}
      		else if(value >= colorMapStart[3] && value <= colorMapEnd[3])
      		{
      			float v = (value - colorMapStart[3]) / (colorMapEnd[3] - colorMapStart[3]);
      			v = (v - colorMapStartValue[3]) / (colorMapEndValue[3] - colorMapStartValue[3]);
      			float a = v * colorMapEndAlpha[3] + (1.0 - v) * colorMapStartAlpha[3];
      			if(colorMapFlipped[3] == 1) v = 1.0 - v;
      			gl_FragColor = vec4(texture2D(colorMap[3], vec2(v, 0.5)).rgb + vec3(-h, h, -h), a + h);
      		}
      		else if(value >= colorMapStart[4] && value <= colorMapEnd[4])
      		{
      			float v = (value - colorMapStart[4]) / (colorMapEnd[4] - colorMapStart[4]);
      			v = (v - colorMapStartValue[4]) / (colorMapEndValue[4] - colorMapStartValue[4]);
      			float a = v * colorMapEndAlpha[4] + (1.0 - v) * colorMapStartAlpha[4];
      			if(colorMapFlipped[4] == 1) v = 1.0 - v;
      			gl_FragColor = vec4(texture2D(colorMap[4], vec2(v, 0.5)).rgb + vec3(-h, h, -h), a + h);
      		}
      		else if(value >= colorMapStart[5] && value <= colorMapEnd[5])
      		{
      			float v = (value - colorMapStart[5]) / (colorMapEnd[5] - colorMapStart[5]);
      			v = (v - colorMapStartValue[5]) / (colorMapEndValue[5] - colorMapStartValue[5]);
      			float a = v * colorMapEndAlpha[5] + (1.0 - v) * colorMapStartAlpha[5];
      			if(colorMapFlipped[5] == 1) v = 1.0 - v;
      			gl_FragColor = vec4(texture2D(colorMap[5], vec2(v, 0.5)).rgb + vec3(-h, h, -h), a + h);
      		}
      		else if(value >= colorMapStart[6] && value <= colorMapEnd[6])
      		{
      			float v = (value - colorMapStart[6]) / (colorMapEnd[6] - colorMapStart[6]);
      			v = (v - colorMapStartValue[6]) / (colorMapEndValue[6] - colorMapStartValue[6]);
      			float a = v * colorMapEndAlpha[6] + (1.0 - v) * colorMapStartAlpha[6];
      			if(colorMapFlipped[6] == 1) v = 1.0 - v;
      			gl_FragColor = vec4(texture2D(colorMap[6], vec2(v, 0.5)).rgb + vec3(-h, h, -h), a + h);
      		}
      		else if(value >= colorMapStart[7] && value <= colorMapEnd[7])
      		{
      			float v = (value - colorMapStart[7]) / (colorMapEnd[7] - colorMapStart[7]);
      			v = (v - colorMapStartValue[7]) / (colorMapEndValue[7] - colorMapStartValue[7]);
      			float a = v * colorMapEndAlpha[7] + (1.0 - v) * colorMapStartAlpha[7];
      			if(colorMapFlipped[7] == 1) v = 1.0 - v;
      			gl_FragColor = vec4(texture2D(colorMap[7], vec2(v, 0.5)).rgb + vec3(-h, h, -h), a + h);
      		}
      		else if(value >= colorMapStart[8] && value <= colorMapEnd[8])
      		{
      			float v = (value - colorMapStart[8]) / (colorMapEnd[8] - colorMapStart[8]);
      			v = (v - colorMapStartValue[8]) / (colorMapEndValue[8] - colorMapStartValue[8]);
      			float a = v * colorMapEndAlpha[8] + (1.0 - v) * colorMapStartAlpha[8];
      			if(colorMapFlipped[8] == 1) v = 1.0 - v;
      			gl_FragColor = vec4(texture2D(colorMap[8], vec2(v, 0.5)).rgb + vec3(-h, h, -h), a + h);
      		}
      		else if(value >= colorMapStart[9] && value <= colorMapEnd[9])
      		{
      			float v = (value - colorMapStart[9]) / (colorMapEnd[9] - colorMapStart[9]);
      			v = (v - colorMapStartValue[9]) / (colorMapEndValue[9] - colorMapStartValue[9]);
      			float a = v * colorMapEndAlpha[9] + (1.0 - v) * colorMapStartAlpha[9];
      			if(colorMapFlipped[9] == 1) v = 1.0 - v;
      			gl_FragColor = vec4(texture2D(colorMap[9], vec2(v, 0.5)).rgb + vec3(-h, h, -h), a + h);
      		}
      		else if(value >= colorMapStart[10] && value <= colorMapEnd[10])
      		{
      			float v = (value - colorMapStart[10]) / (colorMapEnd[10] - colorMapStart[10]);
      			v = (v - colorMapStartValue[10]) / (colorMapEndValue[10] - colorMapStartValue[10]);
      			float a = v * colorMapEndAlpha[10] + (1.0 - v) * colorMapStartAlpha[10];
      			if(colorMapFlipped[10] == 1) v = 1.0 - v;
      			gl_FragColor = vec4(texture2D(colorMap[10], vec2(v, 0.5)).rgb + vec3(-h, h, -h), a + h);
      		}
      		else if(value >= colorMapStart[11] && value <= colorMapEnd[11])
      		{
      			float v = (value - colorMapStart[11]) / (colorMapEnd[11] - colorMapStart[11]);
      			v = (v - colorMapStartValue[11]) / (colorMapEndValue[11] - colorMapStartValue[11]);
      			float a = v * colorMapEndAlpha[11] + (1.0 - v) * colorMapStartAlpha[11];
      			if(colorMapFlipped[11] == 1) v = 1.0 - v;
      			gl_FragColor = vec4(texture2D(colorMap[11], vec2(v, 0.5)).rgb + vec3(-h, h, -h), a + h);
      		}
      		else if(value >= colorMapStart[12] && value <= colorMapEnd[12])
      		{
      			float v = (value - colorMapStart[12]) / (colorMapEnd[12] - colorMapStart[12]);
      			v = (v - colorMapStartValue[12]) / (colorMapEndValue[12] - colorMapStartValue[12]);
      			float a = v * colorMapEndAlpha[12] + (1.0 - v) * colorMapStartAlpha[12];
      			if(colorMapFlipped[12] == 1) v = 1.0 - v;
      			gl_FragColor = vec4(texture2D(colorMap[12], vec2(v, 0.5)).rgb + vec3(-h, h, -h), a + h);
      		}
      		else if(value >= colorMapStart[13] && value <= colorMapEnd[13])
      		{
      			float v = (value - colorMapStart[13]) / (colorMapEnd[13] - colorMapStart[13]);
      			v = (v - colorMapStartValue[13]) / (colorMapEndValue[13] - colorMapStartValue[13]);
      			float a = v * colorMapEndAlpha[13] + (1.0 - v) * colorMapStartAlpha[13];
      			if(colorMapFlipped[13] == 1) v = 1.0 - v;
      			gl_FragColor = vec4(texture2D(colorMap[13], vec2(v, 0.5)).rgb + vec3(-h, h, -h), a + h);
      		}
      		else if(value >= colorMapStart[14] && value <= colorMapEnd[14])
      		{
      			float v = (value - colorMapStart[14]) / (colorMapEnd[14] - colorMapStart[14]);
      			v = (v - colorMapStartValue[14]) / (colorMapEndValue[14] - colorMapStartValue[14]);
      			float a = v * colorMapEndAlpha[14] + (1.0 - v) * colorMapStartAlpha[14];
      			if(colorMapFlipped[14] == 1) v = 1.0 - v;
      			gl_FragColor = vec4(texture2D(colorMap[14], vec2(v, 0.5)).rgb + vec3(-h, h, -h), a + h);
      		}
      	}
    </script>
    <script id="fsColorMap" type="x-shader/x-fragment">
        precision mediump float;
      varying vec2 uv;
      uniform sampler2D colorMap[15];
      uniform float colorMapStart[15], colorMapEnd[15];
      uniform float colorMapStartValue[15], colorMapEndValue[15];
      uniform int colorMapFlipped[15];
      uniform vec3 NanColor;

      void main()
      {
      	/*for(int i = 0; i < 15; ++i)
      		if(uv.x >= colorMapStart[i] && uv.x <= colorMapEnd[i])
      		{
      			float v = (uv.x - colorMapStart[i]) / (colorMapEnd[i] - colorMapStart[i]);
      			v = (v - colorMapStartValue[i]) / (colorMapEndValue[i] - colorMapStartValue[i]);
      			if(colorMapFlipped[i] == 1) v = 1.0 - v;
      			gl_FragColor = vec4(texture2D(colorMap[i], vec2(v, 0.5)).rgb, 1.0);
      			//return; // Warning: This causes artifacts on Chromium (Do not un-comment!)
      		}*/

      	if(uv.x >= colorMapStart[0] && uv.x <= colorMapEnd[0])
      	{
      		float v = (uv.x - colorMapStart[0]) / (colorMapEnd[0] - colorMapStart[0]);
      		v = (v - colorMapStartValue[0]) / (colorMapEndValue[0] - colorMapStartValue[0]);
      		if(colorMapFlipped[0] == 1) v = 1.0 - v;
      		gl_FragColor = vec4(texture2D(colorMap[0], vec2(v, 0.5)).rgb, 1.0);
      	}
      	else if(uv.x >= colorMapStart[1] && uv.x <= colorMapEnd[1])
      	{
      		float v = (uv.x - colorMapStart[1]) / (colorMapEnd[1] - colorMapStart[1]);
      		v = (v - colorMapStartValue[1]) / (colorMapEndValue[1] - colorMapStartValue[1]);
      		if(colorMapFlipped[1] == 1) v = 1.0 - v;
      		gl_FragColor = vec4(texture2D(colorMap[1], vec2(v, 0.5)).rgb, 1.0);
      	}
      	else if(uv.x >= colorMapStart[2] && uv.x <= colorMapEnd[2])
      	{
      		float v = (uv.x - colorMapStart[2]) / (colorMapEnd[2] - colorMapStart[2]);
      		v = (v - colorMapStartValue[2]) / (colorMapEndValue[2] - colorMapStartValue[2]);
      		if(colorMapFlipped[2] == 1) v = 1.0 - v;
      		gl_FragColor = vec4(texture2D(colorMap[2], vec2(v, 0.5)).rgb, 1.0);
      	}
      	else if(uv.x >= colorMapStart[3] && uv.x <= colorMapEnd[3])
      	{
      		float v = (uv.x - colorMapStart[3]) / (colorMapEnd[3] - colorMapStart[3]);
      		v = (v - colorMapStartValue[3]) / (colorMapEndValue[3] - colorMapStartValue[3]);
      		if(colorMapFlipped[3] == 1) v = 1.0 - v;
      		gl_FragColor = vec4(texture2D(colorMap[3], vec2(v, 0.5)).rgb, 1.0);
      	}
      	else if(uv.x >= colorMapStart[4] && uv.x <= colorMapEnd[4])
      	{
      		float v = (uv.x - colorMapStart[4]) / (colorMapEnd[4] - colorMapStart[4]);
      		v = (v - colorMapStartValue[4]) / (colorMapEndValue[4] - colorMapStartValue[4]);
      		if(colorMapFlipped[4] == 1) v = 1.0 - v;
      		gl_FragColor = vec4(texture2D(colorMap[4], vec2(v, 0.5)).rgb, 1.0);
      	}
      	else if(uv.x >= colorMapStart[5] && uv.x <= colorMapEnd[5])
      	{
      		float v = (uv.x - colorMapStart[5]) / (colorMapEnd[5] - colorMapStart[5]);
      		v = (v - colorMapStartValue[5]) / (colorMapEndValue[5] - colorMapStartValue[5]);
      		if(colorMapFlipped[5] == 1) v = 1.0 - v;
      		gl_FragColor = vec4(texture2D(colorMap[5], vec2(v, 0.5)).rgb, 1.0);
      	}
      	else if(uv.x >= colorMapStart[6] && uv.x <= colorMapEnd[6])
      	{
      		float v = (uv.x - colorMapStart[6]) / (colorMapEnd[6] - colorMapStart[6]);
      		v = (v - colorMapStartValue[6]) / (colorMapEndValue[6] - colorMapStartValue[6]);
      		if(colorMapFlipped[6] == 1) v = 1.0 - v;
      		gl_FragColor = vec4(texture2D(colorMap[6], vec2(v, 0.5)).rgb, 1.0);
      	}
      	else if(uv.x >= colorMapStart[7] && uv.x <= colorMapEnd[7])
      	{
      		float v = (uv.x - colorMapStart[7]) / (colorMapEnd[7] - colorMapStart[7]);
      		v = (v - colorMapStartValue[7]) / (colorMapEndValue[7] - colorMapStartValue[7]);
      		if(colorMapFlipped[7] == 1) v = 1.0 - v;
      		gl_FragColor = vec4(texture2D(colorMap[7], vec2(v, 0.5)).rgb, 1.0);
      	}
      	else if(uv.x >= colorMapStart[8] && uv.x <= colorMapEnd[8])
      	{
      		float v = (uv.x - colorMapStart[8]) / (colorMapEnd[8] - colorMapStart[8]);
      		v = (v - colorMapStartValue[8]) / (colorMapEndValue[8] - colorMapStartValue[8]);
      		if(colorMapFlipped[8] == 1) v = 1.0 - v;
      		gl_FragColor = vec4(texture2D(colorMap[8], vec2(v, 0.5)).rgb, 1.0);
      	}
      	else if(uv.x >= colorMapStart[9] && uv.x <= colorMapEnd[9])
      	{
      		float v = (uv.x - colorMapStart[9]) / (colorMapEnd[9] - colorMapStart[9]);
      		v = (v - colorMapStartValue[9]) / (colorMapEndValue[9] - colorMapStartValue[9]);
      		if(colorMapFlipped[9] == 1) v = 1.0 - v;
      		gl_FragColor = vec4(texture2D(colorMap[9], vec2(v, 0.5)).rgb, 1.0);
      	}
      	else if(uv.x >= colorMapStart[10] && uv.x <= colorMapEnd[10])
      	{
      		float v = (uv.x - colorMapStart[10]) / (colorMapEnd[10] - colorMapStart[10]);
      		v = (v - colorMapStartValue[10]) / (colorMapEndValue[10] - colorMapStartValue[10]);
      		if(colorMapFlipped[10] == 1) v = 1.0 - v;
      		gl_FragColor = vec4(texture2D(colorMap[10], vec2(v, 0.5)).rgb, 1.0);
      	}
      	else if(uv.x >= colorMapStart[11] && uv.x <= colorMapEnd[11])
      	{
      		float v = (uv.x - colorMapStart[11]) / (colorMapEnd[11] - colorMapStart[11]);
      		v = (v - colorMapStartValue[11]) / (colorMapEndValue[11] - colorMapStartValue[11]);
      		if(colorMapFlipped[11] == 1) v = 1.0 - v;
      		gl_FragColor = vec4(texture2D(colorMap[11], vec2(v, 0.5)).rgb, 1.0);
      	}
      	else if(uv.x >= colorMapStart[12] && uv.x <= colorMapEnd[12])
      	{
      		float v = (uv.x - colorMapStart[12]) / (colorMapEnd[12] - colorMapStart[12]);
      		v = (v - colorMapStartValue[12]) / (colorMapEndValue[12] - colorMapStartValue[12]);
      		if(colorMapFlipped[12] == 1) v = 1.0 - v;
      		gl_FragColor = vec4(texture2D(colorMap[12], vec2(v, 0.5)).rgb, 1.0);
      	}
      	else if(uv.x >= colorMapStart[13] && uv.x <= colorMapEnd[13])
      	{
      		float v = (uv.x - colorMapStart[13]) / (colorMapEnd[13] - colorMapStart[13]);
      		v = (v - colorMapStartValue[13]) / (colorMapEndValue[13] - colorMapStartValue[13]);
      		if(colorMapFlipped[13] == 1) v = 1.0 - v;
      		gl_FragColor = vec4(texture2D(colorMap[13], vec2(v, 0.5)).rgb, 1.0);
      	}
      	else if(uv.x >= colorMapStart[14] && uv.x <= colorMapEnd[14])
      	{
      		float v = (uv.x - colorMapStart[14]) / (colorMapEnd[14] - colorMapStart[14]);
      		v = (v - colorMapStartValue[14]) / (colorMapEndValue[14] - colorMapStartValue[14]);
      		if(colorMapFlipped[14] == 1) v = 1.0 - v;
      		gl_FragColor = vec4(texture2D(colorMap[14], vec2(v, 0.5)).rgb, 1.0);
      	}
      }
    </script>
  </head>

  <body onload="onLoad()" onresize="onResize()">
    <div id="divColorMapPicker">
      <table id="tableColorMapPicker" cellspacing="0"></table>
    </div>

    <div id="divWorkArea">
      <div id="ImageSection" resize="onResize()">
        <canvas id="cvImage" width="800" height="400"></canvas>

        <div id="ImageControlSection">
          <input
            class="button"
            title="Save Image"
            type="image"
            id="saveImageButton"
            src="saveImageButton.png"
            onclick="saveImages();"
          />
          <!--<input class="button" type="image" id="saveImageButton" src="saveImageButton.png" onclick="imageCanvas.save();"/>-->
          <input
            class="button"
            title="Zoom to Fit"
            type="image"
            id="zoomFitButton"
            src="zoomFitButton.png"
            onclick="imageCanvas.zoomFit()"
          />
          <input
            class="button"
            title="Reset Zoom"
            type="image"
            id="zoomResetButton"
            src="zoomResetButton.png"
            onclick="imageCanvas.zoomReset()"
          />
        </div>
      </div>

      <div id="ColorMapSection">
        <div id="LeftControlSection" align="left">
          <input
            class="button"
            title="Split Colormap"
            type="image"
            id="cmdSplitter"
            src="splitterButton.png"
            onclick="/*hideColorPicker();*/ var canvas = document.getElementById('cvColorMap'); canvas.style.cursor = canvas.style.cursor.indexOf('splitterCursor') != -1 ? CURSOR_DEFAULT : 'url(splitterCursor.png), auto';"
          />
          <input
            class="button"
            title="Delete"
            type="image"
            id="cmdTrash1"
            src="trashButton.png"
          />
          <input
            class="button"
            title="Insert Colormap"
            type="image"
            id="cmdInterjector"
            src="interjectorButton.png"
            onclick="/*hideColorPicker();*/ var canvas = document.getElementById('cvColorMap'); canvas.style.cursor = canvas.style.cursor.indexOf('interjectorCursor') != -1 ? CURSOR_DEFAULT : 'url(interjectorCursor.png) 9 0, auto';"
          />
          <div class="button" id="divUndoRedo">
            <input
              class="narrowButton"
              title="Undo"
              type="image"
              id="cmdUndo"
              src="undoButton.png"
              onclick="actionManager.undo();"
            />
            <input
              class="narrowButton"
              title="Undo"
              type="image"
              id="cmdUndo2"
              src="undoButton2.png"
              onclick="actionManager.undo();"
              style="display: none"
            />
            <input
              class="narrowButton"
              title="Redo"
              type="image"
              id="cmdRedo"
              src="redoButton.png"
              onclick="actionManager.redo();"
            />
            <input
              class="narrowButton"
              title="Redo"
              type="image"
              id="cmdRedo2"
              src="redoButton2.png"
              onclick="actionManager.redo();"
              style="display: none"
            />
          </div>
        </div>
        <div id="LeftHistogramResolution">
          <label
            id="lblHistogramResolution"
            title="Histogram Resolution"
            style="position: relative; top: 166px; visibility: hidden"
          ></label>
          <input
            id="rangeHistogramResolution"
            title="Histogram Resolution"
            type="range"
            orient="vertical"
            min="4"
            max="16"
            value="8"
            step="1"
            oninput="setHistogramResolution()"
          />
        </div>
        <div id="divColorMap">
          <input
            id="lblHistogramH0"
            class="lblHistogramHIn"
            step="any"
            type="number"
            value="0"
            autocomplete="off"
            onchange="setValueRange()"
          />
          <label id="lblHistogramH1" class="lblHistogramH">10</label>
          <label id="lblHistogramH2" class="lblHistogramH">20</label>
          <label id="lblHistogramH3" class="lblHistogramH">30</label>
          <label id="lblHistogramH4" class="lblHistogramH">40</label>
          <label id="lblHistogramH5" class="lblHistogramH">50</label>
          <label id="lblHistogramH6" class="lblHistogramH">60</label>
          <label id="lblHistogramH7" class="lblHistogramH">70</label>
          <label id="lblHistogramH8" class="lblHistogramH">80</label>
          <label id="lblHistogramH9" class="lblHistogramH">90</label>
          <input
            id="lblHistogramH10"
            class="lblHistogramHIn"
            step="any"
            type="number"
            value="100"
            autocomplete="off"
            onchange="setValueRange()"
          />

          <label id="lblHistogramV0" class="lblHistogramV">0%</label>
          <label id="lblHistogramV1" class="lblHistogramV">10%</label>
          <label id="lblHistogramV2" class="lblHistogramV">20%</label>
          <label id="lblHistogramV3" class="lblHistogramV">30%</label>
          <label id="lblHistogramV4" class="lblHistogramV">40%</label>
          <label id="lblHistogramV5" class="lblHistogramV">50%</label>
          <label id="lblHistogramV6" class="lblHistogramV">60%</label>
          <label id="lblHistogramV7" class="lblHistogramV">70%</label>
          <label id="lblHistogramV8" class="lblHistogramV">80%</label>
          <label id="lblHistogramV9" class="lblHistogramV">90%</label>
          <label id="lblHistogramV10" class="lblHistogramV">100%</label>

          <canvas
            id="cvColorMap"
            style="border: none; position: absolute; left: 60; top: 14"
            width="800"
            height="390"
          ></canvas>
          <div
            id="divColorMapBounds"
            style="position: absolute; pointer-events: none"
          ></div>
        </div>
        <div id="RightControlSection" align="right">
          <input
            class="button"
            title="Toggle Color Picker"
            type="image"
            id="cmdColormap"
            src="colorMapButton.png"
            align="right"
            onclick="toggleColorPicker()"
          />
          <input
            class="button"
            title="Delete"
            type="image"
            id="cmdTrash2"
            src="trashButton.png"
            align="right"
          />
          <input
            class="button"
            title="Download Colormap"
            type="image"
            id="cmdSaveColormap"
            src="saveColorMapButton.png"
            align="right"
            onclick="saveColormap();"
          />
          <div id="divHistogramAlpha">
            <input
              class="button"
              title="Enable Opacity Control"
              type="image"
              id="cmdHistogram"
              src="histogramButton.png"
              align="right"
              onclick="onHistogramButtonPressed();"
            />
            <input
              class="button"
              title="Enable Opacity Control with Histogram"
              type="image"
              id="cmdAlpha"
              src="alphaButton.png"
              align="right"
              onclick="onAlphaButtonPressed();"
              style="display: none"
            />
            <input
              class="button"
              title="Disable Opacity Control"
              type="image"
              id="cmdHistogramAlpha"
              src="histogramAlphaButton.png"
              align="right"
              onclick="onHistogramAlphaButtonPressed();"
              style="display: none"
            />
          </div>
        </div>
      </div>
    </div>

    <div id="downloadColormapDialog" title="Download Colormap">
      <p>Select output format ...</p>
    </div>

    <a id="aDownload" download="image.png"></a>

    <script>
      var downloadColormapDialog = $('#downloadColormapDialog').dialog({
        autoOpen: false,
        modal: true,
        resizable: false,
        buttons: {
          XML: function () {
            downloadColormapDialog.dialog('close');
            saveColormapXML();
          },
          JSON: function () {
            downloadColormapDialog.dialog('close');
            saveColormapJSON();
          },
          PNG: function () {
            downloadColormapDialog.dialog('close');
            saveColormapPNG();
          }
        }
      });
      var downloader = document.getElementById('aDownload');

      var imageCanvas, colorMapCanvas;
      var colormapPicker;
      var cvAll = [];
      var lblHistogramH = [],
        lblHistogramV = [];

      var actionManager;

      var COLOR_MAP_SIZE = 1024; //32;
      var HISTOGRAM_SIZE = 200.0;
      var colorMaps = [];

      var fileDropIsCopy = false;

      function onLoad() {
        lblHistogramH.push(document.getElementById('lblHistogramH0'));
        lblHistogramH.push(document.getElementById('lblHistogramH1'));
        lblHistogramH.push(document.getElementById('lblHistogramH2'));
        lblHistogramH.push(document.getElementById('lblHistogramH3'));
        lblHistogramH.push(document.getElementById('lblHistogramH4'));
        lblHistogramH.push(document.getElementById('lblHistogramH5'));
        lblHistogramH.push(document.getElementById('lblHistogramH6'));
        lblHistogramH.push(document.getElementById('lblHistogramH7'));
        lblHistogramH.push(document.getElementById('lblHistogramH8'));
        lblHistogramH.push(document.getElementById('lblHistogramH9'));
        lblHistogramH.push(document.getElementById('lblHistogramH10'));

        lblHistogramV.push(document.getElementById('lblHistogramV0'));
        lblHistogramV.push(document.getElementById('lblHistogramV1'));
        lblHistogramV.push(document.getElementById('lblHistogramV2'));
        lblHistogramV.push(document.getElementById('lblHistogramV3'));
        lblHistogramV.push(document.getElementById('lblHistogramV4'));
        lblHistogramV.push(document.getElementById('lblHistogramV5'));
        lblHistogramV.push(document.getElementById('lblHistogramV6'));
        lblHistogramV.push(document.getElementById('lblHistogramV7'));
        lblHistogramV.push(document.getElementById('lblHistogramV8'));
        lblHistogramV.push(document.getElementById('lblHistogramV9'));
        lblHistogramV.push(document.getElementById('lblHistogramV10'));

        actionManager = new ActionManager(
          document.getElementById('cmdUndo'),
          document.getElementById('cmdUndo2'),
          document.getElementById('cmdRedo'),
          document.getElementById('cmdRedo2')
        );

        var tableColorMapPicker = document.getElementById(
          'tableColorMapPicker'
        );
        tableColorMapPicker.ondrop = handleColorMapDrop;
        tableColorMapPicker.ondragover = function (event) {
          if (event.dataTransfer.types == null) return;
          for (var i = 0; i < event.dataTransfer.types.length; ++i)
            if (event.dataTransfer.types[i] === 'Files') {
              event.preventDefault();
              return;
            }
        };

        var cvImage = document.getElementById('cvImage');
        cvAll.push(
          (imageCanvas = new ImageCanvas(
            cvImage,
            document.getElementById('ImageSection')
          ))
        );
        cvImage.ondrop = handleFileDrop;
        cvImage.ondragleave = function (event) {
          imageCanvas.hideHighlight();
        };
        cvImage.ondragover = function (event) {
          if (event.dataTransfer.types == null) return;
          for (var i = 0; i < event.dataTransfer.types.length; ++i)
            if (event.dataTransfer.types[i] === 'Files') {
              fileDropIsCopy = event.ctrlKey || event.metaKey;
              event.preventDefault();
              var targetRect = event.target.getBoundingClientRect();
              imageCanvas.showHighlight(
                event.clientX - targetRect.left,
                event.clientY - targetRect.top
              );
              return;
            }
        };

        var cvColorMap = document.getElementById('cvColorMap');
        cvAll.push(
          (colorMapCanvas = new ColorMapCanvas(
            cvColorMap,
            document.getElementById('divColorMap'),
            document.getElementById('divColorMapBounds')
          ))
        );
        onHistogramAlphaButtonPressed();

        document.onkeydown = handleKeyDown;
        document.onkeyup = handleKeyUp;
        cvAll.forEach(function (canvas) {
          canvas.canvas.onmousedown = handleMouseDown;
          canvas.canvas.onmouseleave = handleMouseLeave;
          if (canvas.onTouchStart != null)
            canvas.canvas.addEventListener(
              'touchstart',
              canvas.onTouchStart,
              false
            );
          if (canvas.onTouchMove != null)
            canvas.canvas.addEventListener(
              'touchmove',
              canvas.onTouchMove,
              false
            );
          if (canvas.onTouchEnd != null)
            canvas.canvas.addEventListener(
              'touchend',
              canvas.onTouchEnd,
              false
            );
        });
        document.onmouseup = handleMouseUp;
        document.onmousemove = handleMouseMove;

        // Add mouse wheel handler
        // Code block from "http://www.javascriptkit.com/javatutors/onmousewheel.shtml"
        var mousewheelevt = /Firefox/i.test(navigator.userAgent)
          ? 'DOMMouseScroll'
          : 'mousewheel';
        if (document.attachEvent)
          document.attachEvent('on' + mousewheelevt, handleMouseWheel);
        else if (document.addEventListener)
          document.addEventListener(mousewheelevt, handleMouseWheel, false);
        // End code block from "http://www.javascriptkit.com/javatutors/onmousewheel.shtml"

        cvAll.forEach(function (canvas) {
          // Prevent context menu from showing up on right mouse button click
          // Code block from "http://stackoverflow.com/questions/8370213/block-right-clicks-in-canvas-with-webgl-context"
          canvas.canvas.addEventListener(
            'contextmenu',
            function (event) {
              if (event.button === 2) {
                event.preventDefault();
                return false;
              }
            },
            false
          );
          // End code block from "http://stackoverflow.com/questions/8370213/block-right-clicks-in-canvas-with-webgl-context"
        });

        // >>> Create color picker table

        colormapPicker = new ColorMapPicker();
        readColorMapsFromXml(
          'ColorMaps.xml',
          COLOR_MAP_SIZE,
          onColorMapsLoaded
        );

        var solidColorMaps = [];
        /*solidColorMaps.Red = {name: "Red", group: 'Solid', nanclr: [0.0, 0.0, 0.0], bytes: [255, 0, 0, 255]};
        solidColorMaps.Orange = {name: "Orange", group: 'Solid', nanclr: [0.0, 0.0, 0.0], bytes: [255, 128, 0, 255]};
        solidColorMaps.Yellow = {name: "Yellow", group: 'Solid', nanclr: [0.0, 0.0, 0.0], bytes: [255, 255, 0, 255]};
        solidColorMaps.Green = {name: "Green", group: 'Solid', nanclr: [0.0, 0.0, 0.0], bytes: [0, 255, 0, 255]};
        solidColorMaps.Blue = {name: "Blue", group: 'Solid', nanclr: [0.0, 0.0, 0.0], bytes: [0, 0, 255, 255]};
        solidColorMaps.White = {name: "White", group: 'Solid', nanclr: [0.0, 0.0, 0.0], bytes: [255, 255, 255, 255]};
        solidColorMaps.Gray = {name: "Gray", group: 'Solid', nanclr: [0.0, 0.0, 0.0], bytes: [128, 128, 128, 255]};
        solidColorMaps.Black = {name: "Black", group: 'Solid', nanclr: [0.5, 0.5, 0.5], bytes: [0, 0, 0, 255]};*/

        solidColorMaps.Blue = {
          name: 'Blue',
          group: 'Solid',
          nanclr: [0.0, 0.0, 0.0],
          bytes: [45, 81, 163, 255]
        };
        solidColorMaps.LightBlue = {
          name: 'Light Blue',
          group: 'Solid',
          nanclr: [0.0, 0.0, 0.0],
          bytes: [142, 183, 255, 255]
        };
        solidColorMaps.Green = {
          name: 'Green',
          group: 'Solid',
          nanclr: [0.0, 0.0, 0.0],
          bytes: [17, 140, 77, 255]
        };
        solidColorMaps.LightGreen = {
          name: 'Light Green',
          group: 'Solid',
          nanclr: [0.0, 0.0, 0.0],
          bytes: [150, 186, 122, 255]
        };
        solidColorMaps.Purple = {
          name: 'Purple',
          group: 'Solid',
          nanclr: [0.0, 0.0, 0.0],
          bytes: [86, 38, 85, 255]
        };
        solidColorMaps.Pink = {
          name: 'Pink',
          group: 'Solid',
          nanclr: [0.0, 0.0, 0.0],
          bytes: [206, 155, 196, 255]
        };
        solidColorMaps.Yellow = {
          name: 'Yellow',
          group: 'Solid',
          nanclr: [0.0, 0.0, 0.0],
          bytes: [244, 229, 83, 255]
        };
        solidColorMaps.LightYellow = {
          name: 'Light Yellow',
          group: 'Solid',
          nanclr: [0.0, 0.0, 0.0],
          bytes: [242, 235, 148, 255]
        };
        solidColorMaps.Orange = {
          name: 'Orange',
          group: 'Solid',
          nanclr: [0.0, 0.0, 0.0],
          bytes: [247, 158, 67, 255]
        };
        solidColorMaps.LightOrange = {
          name: 'Light Orange',
          group: 'Solid',
          nanclr: [0.0, 0.0, 0.0],
          bytes: [249, 187, 123, 255]
        };
        solidColorMaps.Red = {
          name: 'Red',
          group: 'Solid',
          nanclr: [0.0, 0.0, 0.0],
          bytes: [232, 62, 36, 255]
        };
        solidColorMaps.LightRed = {
          name: 'Light Red',
          group: 'Solid',
          nanclr: [0.0, 0.0, 0.0],
          bytes: [239, 127, 109, 255]
        };
        solidColorMaps.Black = {
          name: 'Black',
          group: 'Solid',
          nanclr: [0.0, 0.0, 0.0],
          bytes: [35, 31, 32, 255]
        };
        solidColorMaps.Brown = {
          name: 'Brown',
          group: 'Solid',
          nanclr: [0.0, 0.0, 0.0],
          bytes: [115, 85, 32, 255]
        };
        solidColorMaps.DarkGray = {
          name: 'Dark Gray',
          group: 'Solid',
          nanclr: [0.0, 0.0, 0.0],
          bytes: [90, 87, 82, 255]
        };
        solidColorMaps.Gray = {
          name: 'Gray',
          group: 'Solid',
          nanclr: [0.0, 0.0, 0.0],
          bytes: [150, 145, 137, 255]
        };
        solidColorMaps.LightGray = {
          name: 'Light Gray',
          group: 'Solid',
          nanclr: [0.0, 0.0, 0.0],
          bytes: [188, 184, 167, 255]
        };
        solidColorMaps.White = {
          name: 'White',
          group: 'Solid',
          nanclr: [0.0, 0.0, 0.0],
          bytes: [255, 255, 255, 255]
        };

        onColorMapsLoaded(solidColorMaps);

        // >>> Register actions

        actionManager.register(
          'ImportColormaps',
          onColorMapsLoaded,
          onColorMapsUnloaded
        );

        /*var image = new Image();
        image.onload = function() {
        	imageCanvas.loadImage("DEBUG.png", image, null, false);
        	setHistogramResolution();
        };
        image.src = "DEBUG.png";*/

        /*var image = new Image();
	image.src = 'debug_bg.png';
	image.onload = function() {
	imageCanvas.loadImage('debug_bg.png', image, null, false, false);

	image = new Image();
	image.src = 'debug_layer3.png';
	image.onload = function() {
		imageCanvas.loadImage('debug_layer3.png', image, null, true, true);
		
		image = new Image();
		image.src = 'debug_layer2.png';
		image.onload = function() {
			imageCanvas.loadImage('debug_layer2.png', image, null, true, true);
			
			image = new Image();
			image.src = 'debug_layer1.png';
			image.onload = function() {
				imageCanvas.loadImage('debug_layer1.png', image, null, true, true);
				
				image = new Image();
				image.src = 'debug_layer0.png';
				image.onload = function() {
					imageCanvas.loadImage('debug_layer0.png', image, null, true, true);
					setHistogramResolution();
				};
			};
		};
	};
};*/

        showColorPicker();
      }

      function onColorMapsLoaded(newColorMaps) {
        // Make colormap name unique
        var pickerChanged = false;
        for (var key in newColorMaps) {
          if (key === '_default') colorMaps._default = newColorMaps._default;
          else {
            // Find unique key
            var uniquekey = key;
            var idx = 1;
            while (colorMaps[uniquekey] != null)
              uniquekey = key + ' [' + ++idx + ']';

            // Update name field of colormap
            newColorMaps[key].name = uniquekey;

            // Append newColorMaps[key] to colorMaps under uniquekey
            colorMaps[uniquekey] = newColorMaps[key];

            if (newColorMaps[key].inPicker) pickerChanged = true;
          }
        }

        // Replace colormap names of embedded colormap sections with colormaps
        for (var colorMapName in newColorMaps)
          if (
            colorMapName !== '_default' &&
            newColorMaps[colorMapName].sections
          ) {
            // If the loaded colormap contains sections and splitters
            var colormap = newColorMaps[colorMapName];
            colormap.sections.forEach(function (section) {
              var cm = colorMaps[section.colorMap]; // Find section colormap by name
              if (cm)
                // If a colormap with the same name exists, ...
                section.colorMap = cm; // Use existing colormap
              // If colormap wasn't found by name
              else {
                if (section.colorMap.interpolatedColorMap == null) {
                  // If section.colorMap == solid color, ...
                  // Try to reproduce this solid-color colormap by its name
                  var clrstr = section.colorMap;
                  if (
                    (clrstr.length =
                      8 && clrstr[0] === '0' && clrstr[1] === 'x')
                  ) {
                    var r = parseInt(clrstr.substr(2, 2), 16);
                    var g = parseInt(clrstr.substr(4, 2), 16);
                    var b = parseInt(clrstr.substr(6, 2), 16);
                    if (
                      r >= 0 &&
                      r < 256 &&
                      g >= 0 &&
                      g < 256 &&
                      b >= 0 &&
                      b < 256
                    ) {
                      var recreatedColormap = {
                        name: section.colorMap,
                        group: 'Solid',
                        nanclr: [0.0, 0.0, 0.0],
                        bytes: [r, g, b, 255],
                        inPicker: false
                      };
                      var recreatedColormaps = [];
                      recreatedColormaps[recreatedColormap.name] =
                        recreatedColormap;
                      onColorMapsLoaded(recreatedColormaps);
                      section.colorMap = recreatedColormap;
                      return;
                    }
                  }
                }

                // Recreate colormap from control points
                var colorTable = new InterpolatedColorMap();
                var controlPointKeys = colormap.interpolatedColorMap.getKeys();
                var controlPoints = colormap.interpolatedColorMap.getSamples();
                controlPointKeys.forEach(function (controlPointKey) {
                  var controlPoint = controlPoints[controlPointKey];
                  if (
                    controlPointKey >= section.start.pos &&
                    controlPointKey <= section.end.pos
                  )
                    colorTable.AddColor(
                      controlPointKey,
                      controlPoint[0],
                      controlPoint[1],
                      controlPoint[2]
                    );
                });

                var recreatedColormap = {
                  name: section.colorMap,
                  group: 'Recreated',
                  nanclr: colormap.nanColor,
                  bytes: colorTable.Create(COLOR_MAP_SIZE),
                  flipped: 0,
                  inPicker: false,
                  interpolatedColorMap: colorTable,
                  //controlPoints: colorTable.getSamples(),
                  //controlPointKeys: colorTable.getKeys(),
                  sections: null,
                  splitters: null
                };
                var recreatedColormaps = [];
                recreatedColormaps[recreatedColormap.name] = recreatedColormap;
                onColorMapsLoaded(recreatedColormaps);
                section.colorMap = recreatedColormap;

                // Information about flipping and cropped regions is lost for recreated colormaps
                section.flipped = false;
                section.startValue = 0.0;
                section.endValue = 1.0;
              }
            });
          }

        // Create colormap textures
        imageCanvas.loadColorMapTextures(COLOR_MAP_SIZE);
        colorMapCanvas.loadColorMapTextures(COLOR_MAP_SIZE);

        if (pickerChanged) colormapPicker.recreatePicker();

        return newColorMaps;
      }

      function onColorMapsUnloaded(unloadedColorMaps) {
        var pickerChanged = false;
        for (var key in unloadedColorMaps)
          if (key !== '_default') {
            var colormap = unloadedColorMaps[key];

            if (colormap.inPicker) pickerChanged = true;

            if (colormap.sections)
              // If the loaded colormap contains sections and splitters
              // Replace colormaps of embedded colormap sections with colormap names
              colormap.sections.forEach(function (section) {
                section.colorMap = section.colorMap.name;
              });

            // Remove colormap from colorMaps
            delete colorMaps[key];
          }

        if (pickerChanged) colormapPicker.recreatePicker();
      }

      function colorMap_onDragStart(event) {
        event.dataTransfer.setData('ColorMapName', event.target.tag_id);
        colorMapCanvas.showTrashButtons();
      }

      function colorMap_onDragEnd() {
        colorMapCanvas.hideTrashButtons();
      }

      function colorMap_onFlipClick(event) {
        var canvas = event.target.tag_canvas;
        var colorMap = event.target.tag_colorMap;

        colorMap.flipped = !colorMap.flipped;

        var ctx = canvas.getContext('2d');
        var imgdata = ctx.getImageData(0, 0, COLOR_MAP_SIZE, 1);
        var colorMap_numpixels = Math.floor(colorMap.bytes.length / 4);
        for (var i = 0; i < colorMap_numpixels; ++i) {
          var j = colorMap.flipped == 1 ? colorMap_numpixels - 1 - i : i;
          imgdata.data[j * 4 + 0] = colorMap.bytes[i * 4 + 0];
          imgdata.data[j * 4 + 1] = colorMap.bytes[i * 4 + 1];
          imgdata.data[j * 4 + 2] = colorMap.bytes[i * 4 + 2];
          imgdata.data[j * 4 + 3] = colorMap.bytes[i * 4 + 3];
        }
        for (var y = 0; y < canvas.height; ++y)
          for (var x = 0; x < COLOR_MAP_SIZE; x += colorMap_numpixels)
            ctx.putImageData(imgdata, x, y);
      }

      /*function getHistogramResolution()
    {
    	var rangeHistogramResolution = document.getElementById('rangeHistogramResolution');
    	return Math.pow(2, rangeHistogramResolution.value);
    }*/
      function setHistogramResolution() {
        var rangeHistogramResolution = document.getElementById(
          'rangeHistogramResolution'
        );
        var lblHistogramResolution = document.getElementById(
          'lblHistogramResolution'
        );
        var resolution = Math.pow(2, rangeHistogramResolution.value);

        //lblHistogramResolution.innerHTML = resolution;
        rangeHistogramResolution.style.visibility = 'visible';
        lblHistogramResolution.style.visibility = 'visible';
        var histograms = imageCanvas.createHistograms(resolution);
        if (histograms.length !== 0) colorMapCanvas.updateHistogram(histograms);
      }

      function showColorPicker() {
        var divColorMapPicker = document.getElementById('divColorMapPicker');
        var divWorkArea = document.getElementById('divWorkArea');

        divColorMapPicker.style.display = 'inline-block';

        var ColorMapPickerWidth = divColorMapPicker.offsetWidth;
        divWorkArea.style.left = ColorMapPickerWidth + 'px';
        divWorkArea.style.width =
          '-moz-calc(100% - ' + divWorkArea.style.left + ')';
        divWorkArea.style.width =
          '-webkit-calc(100% - ' + divWorkArea.style.left + ')';
        divWorkArea.style.width = 'calc(100% - ' + divWorkArea.style.left + ')';

        onResize();
      }

      function hideColorPicker() {
        var divColorMapPicker = document.getElementById('divColorMapPicker');
        var divWorkArea = document.getElementById('divWorkArea');

        divColorMapPicker.style.display = 'none';

        var ColorMapPickerWidth = divColorMapPicker.offsetWidth;
        divWorkArea.style.left = '0px';
        divWorkArea.style.width = '100%';

        onResize();
      }

      function toggleColorPicker() {
        var divColorMapPicker = document.getElementById('divColorMapPicker');
        if (divColorMapPicker.style.display == 'inline-block')
          hideColorPicker();
        else showColorPicker();
      }

      function setValueRange() {
        var histogramH0 = document.getElementById('lblHistogramH0').value;
        var histogramH10 = document.getElementById('lblHistogramH10').value;
        colorMapCanvas.setValueRange(histogramH0, histogramH10);
      }

      function onHistogramButtonPressed() {
        document.getElementById('cmdHistogram').style.display = 'none';
        document.getElementById('cmdAlpha').style.display = 'inline-block';
        document.getElementById('cmdHistogramAlpha').style.display = 'none';
        colorMapCanvas.hideHistogram();
        colorMapCanvas.showAlphaCurve();
      }

      function onAlphaButtonPressed() {
        document.getElementById('cmdHistogram').style.display = 'none';
        document.getElementById('cmdAlpha').style.display = 'none';
        document.getElementById('cmdHistogramAlpha').style.display =
          'inline-block';
        colorMapCanvas.showHistogram();
        colorMapCanvas.showAlphaCurve();
      }

      function onHistogramAlphaButtonPressed() {
        document.getElementById('cmdHistogram').style.display = 'inline-block';
        document.getElementById('cmdAlpha').style.display = 'none';
        document.getElementById('cmdHistogramAlpha').style.display = 'none';
        colorMapCanvas.showHistogram();
        colorMapCanvas.hideAlphaCurve();
      }

      function onResize() {
        var ImageSection = document.getElementById('ImageSection');
        var ColorMapSection = document.getElementById('ColorMapSection');
        var divColorMapPicker = document.getElementById('divColorMapPicker');

        //var cmHeight = window.innerHeight > 2 * HISTOGRAM_SIZE ? HISTOGRAM_SIZE : Math.floor(window.innerHeight / 2);

        //var cmHeight = window.innerHeight > 2 * HISTOGRAM_SIZE ? Math.floor(window.innerHeight / 4) : Math.floor(window.innerHeight / 2);

        var cmHeightMin = 128,
          MinHeight = 512;
        var cmHeightMax = 256,
          MaxHeight = 1024;
        var f = (window.innerHeight - MinHeight) / (MaxHeight - MinHeight);
        f = Math.max(Math.min(f, 1), 0);
        //console.log(f);
        var cmHeight = cmHeightMax * f + cmHeightMin * (1 - f);

        ImageSection.style.height = window.innerHeight - cmHeight - 20;
        ColorMapSection.style.top = window.innerHeight - cmHeight;
        ColorMapSection.style.height = cmHeight - 4;

        //divColorMapPicker.style["max-height"] = window.innerHeight - cmHeight - 10;

        //ImageSection.style.width = window.innerWidth - 16;
        //ColorMapSection.style.width = window.innerWidth ;//- 16;

        var y = 0;
        var h = cmHeight - 12;
        var rangeHistogramResolution = document.getElementById(
          'rangeHistogramResolution'
        );
        if (h > 16) {
          rangeHistogramResolution.style.top = y;
          rangeHistogramResolution.style.height = h;
          rangeHistogramResolution.style.visibility =
            lblHistogramResolution.style.visibility;
        } else rangeHistogramResolution.style.visibility = 'hidden';

        cvAll.forEach(function (canvas) {
          if (typeof canvas.onResize == 'function') canvas.onResize();
        });
      }
      onResize();

      function handleFileSelect(event) {
        var files = event.target.files;
        if (files.length >= 1) {
          var reader = new FileReader();
          reader.onload = function (e) {
            var image = new Image();
            image.onload = function () {
              imageCanvas.loadImage(files[0], image, null, false);
              setHistogramResolution();
            };
            image.src = this.result;
          };
          reader.readAsDataURL(files[0]);
        }
      }

      function handleFileDrop(event) {
        event.preventDefault();
        event = event || window.event;
        imageCanvas.hideHighlight();
        var files = event.files || event.dataTransfer.files;
        if (files) {
          fileDropIsCopy = fileDropIsCopy || event.ctrlKey || event.metaKey;
          var targetRect = event.target.getBoundingClientRect();
          var eventX = event.clientX - targetRect.left;
          var eventY = event.clientY - targetRect.top;
          var fileExt = files[0].name;
          if (fileExt != null) {
            var lastdot = fileExt.lastIndexOf('.');
            if (lastdot != -1) fileExt = fileExt.substring(lastdot + 1);
            else fileExt = null;
          }
          if (fileExt == 'im') {
            var reader = new FileReader();
            reader.onload = function (e) {
              var image = readImImage(new Uint8Array(reader.result));
              var view = imageCanvas.getOrCreateView(eventX, eventY);
              imageCanvas.loadImageFromByteArray(
                files[0].name,
                image.bytes,
                image.width,
                image.height,
                view,
                fileDropIsCopy
              );
              setHistogramResolution();
              colorMapCanvas.setValueRange(image.vmin, image.vmax, '');
            };
            reader.readAsArrayBuffer(files[0]);
          }
          if (fileExt == 'fits') {
            /*var fits = new astro.FITS(files[0], function() {
                    	var dataunit = this.getDataUnit();
                    	console.log("width = " + dataunit.width);
                    	console.log("height = " + dataunit.height);
                    	console.log("depth = " + dataunit.depth);
                    	console.log("bzero = " + dataunit.bzero);
                    	console.log("bscale = " + dataunit.bscale);
                    	console.log("bitpix = " + dataunit.bitpix);
                    	dataunit.getFrame(0, function(array) {
                    		var vmin = Number.MAX_VALUE, vmax = Number.MIN_VALUE;
                    		array.forEach(function(value) {
                    			vmin = Math.min(vmin, value);
                    			vmax = Math.max(vmax, value);
                    		});
                    		var vscale = 1 / (vmax - vmin), numpixels = array.length;
                    		for(var i = 0; i < numpixels; ++i)
                    			array[i] = (array[i] - vmin) * vscale;
                    		//array = new Float32Array(dataunit.width * dataunit.height);
                    		var view = imageCanvas.getOrCreateView(eventX, eventY);
                    		imageCanvas.loadImageFromFloatArray(files[0].name, array, dataunit.width, dataunit.height, view, fileDropIsCopy);
                    		setHistogramResolution();
                    		colorMapCanvas.setValueRange(vmin, vmax, '');
                    	});
                    });*/
            readFitsImage(
              files[0],
              function (err) {
                alert(err);
              },
              function (bytes, width, height, vmin, vmax) {
                var view = imageCanvas.getOrCreateView(eventX, eventY);
                imageCanvas.loadImageFromByteArray(
                  files[0].name,
                  bytes,
                  width,
                  height,
                  view,
                  fileDropIsCopy
                );
                setHistogramResolution();
                colorMapCanvas.setValueRange(vmin, vmax, '');
              },
              function (floats, width, height, vmin, vmax) {
                var view = imageCanvas.getOrCreateView(eventX, eventY);
                imageCanvas.loadImageFromFloatArray(
                  files[0].name,
                  floats,
                  width,
                  height,
                  view,
                  fileDropIsCopy
                );
                setHistogramResolution();
                colorMapCanvas.setValueRange(vmin, vmax, '');
              }
            );
          } // Default extension: png
          else {
            // Load image
            var reader = new FileReader();
            reader.onload = function (e) {
              var image = new Image();
              image.onload = function () {
                var view = imageCanvas.getOrCreateView(eventX, eventY);
                imageCanvas.loadImage(
                  files[0].name,
                  image,
                  view,
                  fileDropIsCopy
                );
                setHistogramResolution();
              };
              image.src = this.result;
            };
            reader.readAsDataURL(files[0]);

            // Load value range from PNG tEXt chunks
            reader = new FileReader();
            reader.onload = function () {
              var chunks = readPngChunks(new Uint8Array(reader.result));
              //printPngChunks(chunks);
              if (chunks != null) {
                // If PNG chunks were found:
                var meta = getPngMetaData(chunks); // Read tEXt chunks into meta
                var minValue = meta.MinValue,
                  maxValue = meta.MaxValue;
                if (minValue != null && maxValue != null) {
                  //var suffix = (minValue.endsWith('%') && maxValue.endsWith('%')) ? '%' : '';
                  var suffix = minValue.substring(
                    ('' + parseFloat(minValue)).length
                  );
                  colorMapCanvas.setValueRange(
                    parseFloat(minValue),
                    parseFloat(maxValue),
                    suffix
                  );
                } else colorMapCanvas.setValueRange(0, 100, '%'); // Default to (0%; 100%)
              } else colorMapCanvas.setValueRange(0, 100, '%'); // Default to (0%; 100%)
            };
            reader.readAsArrayBuffer(files[0]);
          }
        }
      }

      function handleColorMapDrop(event) {
        event.preventDefault();
        event = event || window.event;
        var files = event.files || event.dataTransfer.files;
        if (files)
          for (var i = 0; i < files.length; ++i) {
            var reader = new FileReader();
            reader.onload = function (e) {
              readColorMapsFromXml(
                this.result,
                COLOR_MAP_SIZE,
                function (newcolormaps) {
                  actionManager.perform('ImportColormaps', newcolormaps);
                }
              );
            };
            reader.readAsDataURL(files[i]);
          }
      }

      var ctrlPressed = false;
      var CTRL = navigator.appVersion.indexOf('Mac') == -1 ? 17 : 224;

      function handleKeyDown(event) {
        if (event.keyCode === CTRL) ctrlPressed = true;

        if (ctrlPressed)
          switch (event.keyCode) {
            case 90:
              event.preventDefault();
              actionManager.undo();
              return;
            case 89:
              event.preventDefault();
              actionManager.redo();
              return;
          }

        switch (event.keyCode) {
          case 37: // Left arrow key
            imageCanvas.prevImage();
            setHistogramResolution();
            return;
          case 39: // Right arrow key
            imageCanvas.nextImage();
            setHistogramResolution();
            return;
        }
      }

      function handleKeyUp(event) {
        if (event.which === CTRL) ctrlPressed = false;
      }

      function onColorTableChanged(sections) {
        imageCanvas.setColorMap(sections);
        colorMapCanvas.setColorMap(sections);
      }

      function saveColormap() {
        downloadColormapDialog.dialog('open');
      }

      function saveColormapXML() {
        var cm = colorMapCanvas.serializeColorMap(new ColormapXmlSerializer());
        //console.log(cm);
        downloader.href = 'data:application/xml;charset=utf-8,' + cm;
        downloader.download = 'colormap.xml';
        downloader.click();
      }

      function saveColormapJSON() {
        var cm = colorMapCanvas.serializeColorMap(new ColormapJsonSerializer());
        //console.log(cm);
        downloader.href = 'data:application/json;charset=utf-8,' + cm;
        downloader.download = 'colormap.json';
        downloader.click();
      }

      function saveColormapPNG() {
        var cm = colorMapCanvas.serializeColorMap(
          new ColormapPngSerializer(1024, 32)
        );
        downloader.href = cm;
        downloader.download = 'colormap.png';
        downloader.click();
      }

      function saveImages() {
        var images = imageCanvas.save();

        if (images.length === 1) {
          downloader.href = images[0].dataURL;
          downloader.download = images[0].name;
          downloader.click();
        } else if (images.length > 1) {
          var zip = new JSZip();
          var filenameCounter = {};
          images.forEach(function (image) {
            // Convert base64-dataURL to base64
            image.dataURL = image.dataURL.substr(
              image.dataURL.indexOf('base64,') + 'base64,'.length
            );

            // Rename duplicate files
            var filenameCount = ++filenameCounter[image.name];
            if (Number.isNaN(filenameCount)) filenameCounter[image.name] = 1;
            else
              image.name =
                image.name.substr(0, image.name.length - '.png'.length) +
                ' (' +
                filenameCount +
                ').png';

            zip.file(image.name, image.dataURL, {
              base64: true
            });
          });
          zip
            .generateAsync({
              type: 'base64'
            })
            .then(function (base64) {
              downloader.href = 'data:application/zip;base64,' + base64;
              downloader.download = 'images.zip';
              downloader.click();
            });
        }
      }

      var ofd = document.getElementById('ofd');
      if (ofd !== null) ofd.addEventListener('change', handleFileSelect, false);
    </script>
  </body>
</html>
